this is a Binary Tree Bottom View problem (GFG).
Letâ€™s go step-by-step so you can understand, remember, and apply this pattern easily in future.

ğŸŒ³ Problem Restatement

We need to find the bottom view of a binary tree â€” i.e., the nodes visible when viewed from the bottom.

ğŸ§  Key Intuition:

Each node has a horizontal distance (HD) from the root:

Root â†’ HD = 0

Left child â†’ HD = parent HD - 1

Right child â†’ HD = parent HD + 1

When you traverse the tree level-by-level (BFS), the latest node encountered for each HD will be the bottommost one.

âœ… Approach: Level Order Traversal (BFS) + Horizontal Distance Mapping

Weâ€™ll use:

A queue for level order traversal storing {node, HD} pairs.

A map<int, int> to store HD â†’ node->data (automatically sorted by HD).

At the end, the mapâ€™s values (from leftmost HD to rightmost) give the bottom view.

âš™ï¸ Step-by-Step Logic

Create a queue of pairs {Node*, int} where int is horizontal distance.

Start with {root, 0}.

Perform level order traversal:

Pop node and its HD.

Store/update the map: mp[hd] = node->data
(latest node at same HD replaces previous â€” ensures bottommost)

Push left child with hd - 1.

Push right child with hd + 1.

After traversal, collect map values in order of increasing HD.

ğŸ’» Full Code (C++ with Explanation)
class Solution {
  public:
    vector<int> bottomView(Node *root) {
        vector<int> ans;
        if (!root) return ans;

        // Map to store hd â†’ node value
        map<int, int> mp;
        
        // Queue for BFS: stores {node, horizontal_distance}
        queue<pair<Node*, int>> q;
        q.push({root, 0});

        while (!q.empty()) {
            auto it = q.front();
            q.pop();

            Node* node = it.first;
            int hd = it.second;

            // Update map (latest node at this HD replaces previous)
            mp[hd] = node->data;

            // Push children with updated HD
            if (node->left)
                q.push({node->left, hd - 1});
            if (node->right)
                q.push({node->right, hd + 1});
        }

        // Extract bottom view from leftmost to rightmost HD
        for (auto &p : mp)
            ans.push_back(p.second);

        return ans;
    }
};

â±ï¸ Complexity Analysis
Type	Complexity
Time	O(N) â€” each node visited once
Space	O(N) â€” for queue + map
ğŸ§© Pattern Recognition

This belongs to the Horizontal Distance + Level Order family:

Top View â†’ first node at each HD

Bottom View â†’ last node at each HD

Vertical Order Traversal â†’ all nodes grouped by HD

ğŸ‘‰ Common Trick: use a map of hd â†’ vector<int> or hd â†’ value and BFS traversal.

ğŸ¯ Quick Recap
Problem	Keep in map?	Update Condition	View
Top View	if not present	only first	Seen from top
Bottom View	always update	last one wins	Seen from bottom
