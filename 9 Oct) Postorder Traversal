Postorder Traversal of a Binary Tree (GFG/Leetcode style) in four complete approaches â€” recursive, using one stack, using two stacks, and Morris traversal â€” with step-by-step explanation and fully commented C++ code âœ…

ğŸŒ³ Problem: Postorder Traversal

Definition:
In Postorder Traversal, we visit nodes in the following order:
ğŸ‘‰ Left â†’ Right â†’ Root

ğŸ§© 1ï¸âƒ£ Recursive Solution
ğŸ”¹ Idea:

Traverse left subtree

Traverse right subtree

Process (store) current node value

ğŸ§  Recurrence Relation:
postorder(root) = postorder(root->left)
                + postorder(root->right)
                + root->data

ğŸ§® Time Complexity:

O(N) â€” every node visited once

ğŸ’¾ Space Complexity:

O(H) â€” recursion stack height (H = height of tree)

ğŸ’» Code:
class Solution {
  public:
    void solve(Node* root, vector<int>& ans) {
        if (root == NULL) return;
        
        // Left subtree
        solve(root->left, ans);
        // Right subtree
        solve(root->right, ans);
        // Process current node
        ans.push_back(root->data);
    }
    
    vector<int> postOrder(Node* root) {
        vector<int> ans;
        solve(root, ans);
        return ans;
    }
};

ğŸ§© 2ï¸âƒ£ Iterative (Using Two Stacks)
ğŸ”¹ Idea:

Use stack1 for traversal.

Use stack2 to store nodes in Root â†’ Right â†’ Left order.

Reverse stack2 at the end to get Left â†’ Right â†’ Root (Postorder).

ğŸ§® Time: O(N) | Space: O(N)
ğŸ’» Code:
class Solution {
  public:
    vector<int> postOrder(Node* root) {
        vector<int> ans;
        if (root == NULL) return ans;
        
        stack<Node*> st1, st2;
        st1.push(root);
        
        while (!st1.empty()) {
            Node* node = st1.top();
            st1.pop();
            st2.push(node);
            
            if (node->left) st1.push(node->left);
            if (node->right) st1.push(node->right);
        }
        
        // Reverse the order using second stack
        while (!st2.empty()) {
            ans.push_back(st2.top()->data);
            st2.pop();
        }
        return ans;
    }
};

ğŸ§© 3ï¸âƒ£ Iterative (Using One Stack)
ğŸ”¹ Idea:

Simulate recursion manually.

Use pointer to track previously visited nodes.

ğŸ” Steps:

Go as left as possible.

Peek top node.

If right child exists and not visited â†’ move to right.

Else â†’ process (pop and add to answer).

ğŸ§® Time: O(N) | Space: O(N)
ğŸ’» Code:
class Solution {
  public:
    vector<int> postOrder(Node* root) {
        vector<int> ans;
        if (root == NULL) return ans;
        
        stack<Node*> st;
        Node* curr = root;
        Node* lastVisited = NULL;
        
        while (!st.empty() || curr != NULL) {
            if (curr != NULL) {
                st.push(curr);
                curr = curr->left;
            } else {
                Node* peekNode = st.top();
                
                // If right child exists and not visited, move right
                if (peekNode->right != NULL && lastVisited != peekNode->right) {
                    curr = peekNode->right;
                } else {
                    ans.push_back(peekNode->data);
                    lastVisited = peekNode;
                    st.pop();
                }
            }
        }
        return ans;
    }
};

ğŸ§© 4ï¸âƒ£ Morris Postorder Traversal (O(1) Space)
ğŸ”¹ Idea:

Use threaded binary tree concept.
Create temporary links to predecessors and reverse result.

ğŸ§® Time: O(N) | Space: O(1)

(Space-efficient but complex â€” rarely used in interviews.)

ğŸ§  Pattern Recognition for Interview:
Traversal	Order	Common Trick
Preorder	Root â†’ Left â†’ Right	Use stack and push Right first, then Left
Inorder	Left â†’ Root â†’ Right	Use controlled traversal with stack
Postorder	Left â†’ Right â†’ Root	Use two stacks or one stack with tracking
ğŸª¶ Interview Tip:

ğŸ”¥ If asked to implement postorder iteratively, the two-stack method is the easiest to write under pressure.

âœ… Use one stack if interviewer asks for â€œoptimized versionâ€.
