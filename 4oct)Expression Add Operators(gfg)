ğŸ” Problem Restatement

We need to generate all possible expressions by inserting +, -, * between digits of string s.
The result of the evaluated expression must equal target.

Constraints:

No leading zeros ("05" is invalid).

Digits must be used in order.

Return answers in lexicographically sorted order.

ğŸ§  Approach
1. Recursive Backtracking

At every step, we can either:

Take the next digit(s) as a number (substring â†’ integer).

Insert an operator (+, -, or *) before that number (except the very first one).

Recurse further until we reach the end of string.

2. Key Challenges

Handling leading zeros (skip numbers like "05").

Correct evaluation with multiplication precedence:

When we do a*b, we need to adjust the running expression.
Example: For 1+2*3, when we add *3, we must undo the previous +2 and replace with +(2*3).

3. Tracking State

We keep track of:

pos: current index in string s.

expr: current expression string formed so far.

currVal: evaluated value of expression so far.

prevNum: the last chosen number (needed for multiplication correction).

4. Recurrence Relation

At each step:

pick substring s[pos..i] as num
if pos == 0:
   recurse(i+1, expr + num, num, num)
else:
   recurse(i+1, expr + "+" + num, currVal + num, +num)
   recurse(i+1, expr + "-" + num, currVal - num, -num)
   recurse(i+1, expr + "*" + num, currVal - prevNum + prevNum*num, prevNum*num)

ğŸ§¾ C++ Code (Backtracking)
class Solution {
public:
    vector<string> ans;
    
    void backtrack(string &s, int target, int pos, long currVal, long prevNum, string expr) {
        // If we've used all digits
        if (pos == s.size()) {
            if (currVal == target) ans.push_back(expr);
            return;
        }

        for (int i = pos; i < s.size(); i++) {
            // Prevent leading zeros
            if (i != pos && s[pos] == '0') break;

            string part = s.substr(pos, i - pos + 1);
            long num = stol(part);

            if (pos == 0) {
                // First number â†’ no operator before it
                backtrack(s, target, i + 1, num, num, part);
            } else {
                // Try '+'
                backtrack(s, target, i + 1, currVal + num, num, expr + "+" + part);

                // Try '-'
                backtrack(s, target, i + 1, currVal - num, -num, expr + "-" + part);

                // Try '*'
                backtrack(s, target, i + 1, currVal - prevNum + prevNum * num,
                          prevNum * num, expr + "*" + part);
            }
        }
    }

    vector<string> findExpr(string &s, int target) {
        ans.clear();
        backtrack(s, target, 0, 0, 0, "");
        sort(ans.begin(), ans.end()); // Lexicographically smallest order
        return ans;
    }
};

âœ… Example Dry Run

Input: s = "124", target = 9

Start: 1 â†’ recurse

1+2 â†’ recurse

1+2+4 = 7 âŒ

1+2-4 = -1 âŒ

1+2*4 = 9 âœ… â†’ add "1+2*4"

1-2 â†’ recurse

1-2+4 = 3 âŒ

1-2-4 = -5 âŒ

1-2*4 = -7 âŒ

1*2 â†’ recurse

1*2+4 = 6 âŒ

1*2-4 = -2 âŒ

1*2*4 = 8 âŒ

Other starting splits checked but fail.

Final answer: ["1+2*4"]

ğŸ“Š Complexity

Time: 
ğ‘‚
(
3
ğ‘
âˆ’
1
)
O(3
Nâˆ’1
) (at each split we try 3 operators).

Space: 
ğ‘‚
(
ğ‘
)
O(N) recursion depth (expression string building).

ğŸ‘‰ This is a classic recursion + backtracking with handling multiplication carefully.





Perfect ğŸ‘ letâ€™s do this with inline annotated code + dry run example for
Expression Add Operators.

Weâ€™ll take your input:
s = "124", target = 9

ğŸ” Fully Annotated Code with Inline Dry Run
class Solution {
public:
    vector<string> ans;

    // Helper recursive function
    void backtrack(string &s, int target, int pos, long currVal, long prevNum, string expr) {
        // âœ… Base case: if we've consumed the whole string
        if (pos == s.size()) {
            if (currVal == target) {
                ans.push_back(expr);  // found a valid expression
            }
            return;
        }

        // Explore every possible next number by cutting substring
        for (int i = pos; i < s.size(); i++) {
            // ğŸš¨ Avoid numbers with leading zeros
            if (i != pos && s[pos] == '0') break;

            string part = s.substr(pos, i - pos + 1); // current number string
            long num = stol(part); // convert to number

            if (pos == 0) {
                // âœ¨ First number (no operator before it)
                // Example: start with "1"
                backtrack(s, target, i + 1, num, num, part);
            } else {
                // â• Try "+"
                backtrack(s, target, i + 1,
                          currVal + num,       // add to total
                          num,                 // prevNum = +num
                          expr + "+" + part);  // append to expr

                // â– Try "-"
                backtrack(s, target, i + 1,
                          currVal - num,       // subtract from total
                          -num,                // prevNum = -num
                          expr + "-" + part);

                // âœ–ï¸ Try "*"
                // undo last addition/subtraction of prevNum, then add prevNum*num
                backtrack(s, target, i + 1,
                          currVal - prevNum + prevNum * num,
                          prevNum * num,       // new prevNum
                          expr + "*" + part);
            }
        }
    }

    vector<string> findExpr(string &s, int target) {
        ans.clear();
        backtrack(s, target, 0, 0, 0, "");
        sort(ans.begin(), ans.end()); // lexicographic order
        return ans;
    }
};

ğŸŸ¢ Dry Run for Input: s = "124", target = 9
Step 1: Start with "1"

pos=0, expr="1", currVal=1, prevNum=1

Now explore next digits:

Case A: "1+2"

currVal = 3, prevNum = 2, expr = "1+2"

Next add "4":

"1+2+4" â†’ 7 âŒ

"1+2-4" â†’ -1 âŒ

"1+2*4" â†’ adjust: 3 - 2 + (2*4) = 9 âœ… add "1+2*4"

Case B: "1-2"

currVal = -1, prevNum = -2, expr = "1-2"

Next add "4":

"1-2+4" â†’ 3 âŒ

"1-2-4" â†’ -5 âŒ

"1-2*4" â†’ -1 - (-2) + (-2*4) = -7 âŒ

Case C: "1*2"

currVal = 2, prevNum = 2, expr = "1*2"

Next add "4":

"1*2+4" â†’ 6 âŒ

"1*2-4" â†’ -2 âŒ

"1*2*4" â†’ 2 - 2 + (2*4) = 8 âŒ

Step 2: Start with "12"

pos=0, expr="12", currVal=12, prevNum=12

Next add "4":

"12+4" â†’ 16 âŒ

"12-4" â†’ 8 âŒ

"12*4" â†’ 48 âŒ

Step 3: Start with "124"

pos=0, expr="124", currVal=124, prevNum=124

End of string â†’ 124 â‰  9 âŒ

âœ… Final Answer: ["1+2*4"]

ğŸ“Š Summary

Backtracking recursion tree tries all operator insertions.

Multiplication handled with correction trick (currVal - prevNum + prevNum*num).

Only valid â†’ "1+2*4".

Do you want me to also draw a recursion tree diagram ğŸ“‰ for this dry run (so you can visualize how calls branch out)?

You said:
yes
ChatGPT said:

Perfect ğŸ™Œ Letâ€™s draw the recursion tree diagram for

s = "124", target = 9

ğŸŒ³ Recursion Tree (Backtracking Exploration)

We start from the root with pos=0 (no operator yet).
At each step, we split digits â†’ choose substring â†’ try operators.

Root:
Start: "" (empty), currVal=0
Pick first number:
 â”œâ”€â”€ "1"
 â”œâ”€â”€ "12"
 â””â”€â”€ "124"

Branch: "1"

Now at pos=1, we can attach operators with next substring "2":

"1"
 â”œâ”€â”€ "1+2"
 â”‚     â”œâ”€â”€ "1+2+4" = 7 âŒ
 â”‚     â”œâ”€â”€ "1+2-4" = -1 âŒ
 â”‚     â””â”€â”€ "1+2*4" = 9 âœ…  <-- Answer
 â”‚
 â”œâ”€â”€ "1-2"
 â”‚     â”œâ”€â”€ "1-2+4" = 3 âŒ
 â”‚     â”œâ”€â”€ "1-2-4" = -5 âŒ
 â”‚     â””â”€â”€ "1-2*4" = -7 âŒ
 â”‚
 â””â”€â”€ "1*2"
       â”œâ”€â”€ "1*2+4" = 6 âŒ
       â”œâ”€â”€ "1*2-4" = -2 âŒ
       â””â”€â”€ "1*2*4" = 8 âŒ

Branch: "12"

At pos=2, substring "4" remains:

"12"
 â”œâ”€â”€ "12+4" = 16 âŒ
 â”œâ”€â”€ "12-4" = 8 âŒ
 â””â”€â”€ "12*4" = 48 âŒ

Branch: "124"

This is already the whole string:

"124" = 124 âŒ

âœ… Final Answer Path

Only one valid leaf in recursion tree:

"1+2*4" = 9

ğŸ“Š Visualization Summary

The recursion tree has 3 main roots: "1", "12", "124".

"1" expands further because digits left â†’ attaches operators.

Only "1+2*4" satisfies target = 9.
